---
title: " documentation - import scan HDR data"
subtitle: "reportings on functional development"
author: "Julia Ortmann"
output: 
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: '3'
    theme:
      bg: "#202123"
      fg: "#B8BCC2"
      primary: "#EA80FC"
      secondary: "#00DAC6"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
abstract: The aim of this build functions for import of scan HDR images, defined by scan_ID
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = "inst/report/dev report - import scan HDR image data.html",
      envir = globalenv()
    )
  })
---

```{r setup, include=FALSE}
if (requireNamespace("thematic")) 
  thematic::thematic_rmd(font = "auto")
```

# summary

... 

# introduction 

- map over chip_IDs
- find scan_IDs 
- find positions measured and subselected (TO DISCUSS)
- select approbriate scan images
- import blob files
- set grey value threshold
- sum tissue-pixels and position-pixel
- calculate tissue AREA and POSITION AREA
- count cells
- export chipID cell_count tissue and position area 

## import scan HDR image {.tabset .tabset-pills}




```{r}
#library(tidyverse)
#library(xml2)
#library(rvest) #e.g. xml_nodes()


#library(zellkraftwerkr)

#source("helperfunctions/connect_mongoDB.R")
#source("helperfunctions/find_scanID.R")
```

# data

```{r}
scan_IDs<-find_scanID(AkID="MZKL211631",StainType="Chipcytometry-Stain*")%>%
  filter(!is.na(ScanID))

head(scan_IDs)
```

# Suche alle relevanten Scanbilder eines Antikörpers

- Scandaten befinden sich im Ordnerpfad: ZKWSCANSRV2 imagedata leipzig_volume0
- es gibt verschiedene volumes 
- den fehlenden Pfad zu den Dateien findet man in der scans collection, suche nach der UID
- Bilderzusatz befindet sich in der scan.EDL
- die scan.EDL befindet sich im übergeordneten Ordner (scanjobs) und heißt wie basePath + _scan.edl

- lese Bilder ein

- mit der ScanID kann man sich die Metadaten zu einem Scan aus der mongoDB: scan-collection holen

## find image - filepath of all scans

find herraus, in welchem server_path die Dateien zu einem bestimmten base_path liegen und füge Spalte server_path in die Datei file_path ein

```{r}
# find basePath to the image folder

file_path<-scan_IDs%>%
  mutate(file_path=map(ScanID,
                       ~ query_mongoDB(search_value=.x,
                                       mongo_collection = "scans",
                                       search_object = "UID",
                                       return_columns = "basePath")))%>%
  unnest(file_path)%>%
  select(basePath,everything())

head(file_path)
```
 
- es gibt eins + drei EDL's einmal im übergeordneten scanjob Ordner, und je eine im pos/hdr , pos/flimages , pos/posref Ordner die Angaben zur Imageaufnahme enthalten (wieviel Pixel, encoding, pixel format, statistic der detektierten Daten = Wertebereich der Intensitäten per Pixel) 

## find global ZKW path

- verschiedene ZKWSCANSRV2 imagedata volume paths gibt es
- soll nicht hard gecoded werden, individuell für jeden user
- ZKW path findet man in limslager: EDLType=ImageServerPath , FlagEmpty=0 , Do_Not_Check darf nicht null sein
- extrahiere alle EDLName das sind die verschiedenen ServerSites, auf denen die Daten abgelegt sein können
- find ServerPath of the ScanID's

```{r}
server_path<-query_mongoDB(search_value="ImageServerPath",
                           mongo_collection = "limslager",
                           search_object = "EDLType",
                           return_columns = c("FlagEmpty","EDLName"))%>% #,"Do_Not_Check" gibts gar nicht
  filter(FlagEmpty == 0)

server_path
```

## find ServerPath of the scanID's

**create function**

```{r}
#for testing
head(file_path)

image_path<-"M619946\\scanjobs\\EZKL150741"

# create function

find_server_path<-function(server_path, file_path){
  
  positions<-vector()
  i=1
  
  while ((purrr::is_empty(positions)) & (i <= length(server_path))){
    
    position_path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\',server_path[i],"\\",file_path)
    
    if(file.exists(position_path)==T){
      positions=paste0('\\\\ZKWSCANSRV2\\imagedata\\',server_path[i])%>%file.path()
    }
    
    i=i+1
  }
  
  if((purrr::is_empty(positions)) & (i <= length(server_path))){
    positions = NA
  }
  
  print(positions)
  return(positions)
  
}

#test function
find_server_path(server_path$EDLName,image_path)

```

**apply function**

```{r}

file_path$server_path<-NA
file_path<-file_path%>%
  select(server_path,everything())

for (j in 1:dim(file_path)[1]){
  
  file_path[j,'server_path']<-find_server_path(server_path = server_path$EDLName,
                                               file_path = file_path[j,'basePath'])
  
}

```


## find all positions of a scan

**toDO**

server_path nicht hard-coden

```{r}
# find all Positions measured on the chip with a certain stain

image_path<-"M619946\\scanjobs\\EZKL150741"  #basePath

position_path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path)

positions<-list.files(path=position_path)

positions<-tibble(positions=positions[str_detect(positions,"pos")],)

```

## finde für jede Position den Namen der binären hdr und der XML Datei

**toDO**

server_path nicht hard-coden

**function**

```{r}
# for testing
#position <- positions[1,'positions']
image_path<-"M619946\\scanjobs\\EZKL150741"

#function body
get_blob_name<-function(image_path, position){
  
  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',position,'\\hdr')%>%
    file.path()
  
  files<-list.files(path)
  file<-files[str_detect(files,".blob32$")]
  file<-file%>%str_remove(".blob32$")
  
  return (file)
}

```

**apply function**
{EDLType: 'ImageServerPath', FlagEmpty: "0" }
```{r}
# map through all positions of a scan and find blob32 file name (equals xml)

positions<-positions%>%
  mutate(blob_file_name=map2_chr(image_path,positions,~get_blob_name(.x,.y)))

positions
```

## add picture characteristics to positions df

**toDO**

server_path nicht hard-coden

**function**

```{r}
#for testing
image_path<-"M619946\\scanjobs\\EZKL150741"

# suche für jede Position aus der XML die notwendigen Infos heraus, damit die HDR Blob eingelesen werden kann
#width=1392
#height=1040
#encoding="32bit-little-endian"

# statistic parameter um den Einlesevorgang zu überprüfen
# min
# max
# distinct
# median

find_picture_informations<- function(image_path, blob_file_name, positions) {
  
#  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',positions[1,"positions"],'\\hdr\\',positions[1,"blob_file_name"],".blob32.xml")%>%
    path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',positions,'\\hdr\\',blob_file_name,".blob32.xml")%>%
      file.path()
  
  file<-read_xml(path)
  
  size<-file%>%xml_child("size")%>%xml_attrs("size")
  structure<-file%>%xml_child("data-structure")%>%xml_attrs("data-structure")
  statistics<-file%>%xml_child("metadata")%>%xml_child("statistics")%>%xml_attrs("statistics")
  picture_size<-file%>%xml_child("metadata")%>%xml_child("extent")%>%xml_attrs("extent") 
  
  #parameter<-tibble(value=c(size,structure,statistics),
  #                  name=c(names(size),names(structure),names(statistics)))
  #names(parameter) <- c(names(size),names(structure),names(statistics))
  
  parameter<-c(size,structure,statistics,picture_size)
  
  return(parameter)
}

```

**apply function**

```{r}
positions<-positions%>%
  mutate(parameter = map2(blob_file_name,
                          positions,
                          ~ find_picture_informations(image_path, .x ,.y)))

positions
#%>%
#  unnest(parameter)%>%
#  spread(name,value)
```

## add list column to positions df, containing intensitys per pixel

```{r}
image_path<-"M619946\\scanjobs\\EZKL150741"
positions%>%head()
```

**toDO**

server_path nicht hard-coden

**function**

```{r}
# for testing
#pos<-positions[1,]
#width=1392
#height=1040
#encoding="32bit-little-endian"
#parameter<-positions[1,'parameter']



read_image_bin <- function(image_path, position, blob_file_name, parameter) {
  
  #parameter<-pos['parameter']%>%flatten()
  parameter<-parameter%>%flatten()
  encoding<-parameter[["parameter"]][["encoding"]]
  
  bin_size<-case_when(encoding == "32bit-little-endian" ~ 4,
                      encoding == "16bit-little-endian" ~ 2)
  
  width<-parameter[["parameter"]][["width"]]%>%as.numeric()
  height<-parameter[["parameter"]][["height"]]%>%as.numeric()
  n_pixels<-width * height
  
  #path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',pos$positions,'\\hdr\\',pos$blob_file_name,".blob32")%>%
  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',position,'\\hdr\\',blob_file_name,".blob32")%>%
    file.path()
  
  data<-readBin(path,
                integer(),
                n=n_pixels,
                size=bin_size)
  
  return (data)
} 

```

**apply function**

```{r}
data<-list()
for(i in 1: dim(positions)[1]){
  
  data_read<-read_image_bin(image_path,positions[i,'positions'],positions[i,'blob_file_name'],positions[i,'parameter'])
  data_read<-list(meta_data=positions[i,],data=data_read)
  data<-c(data,list(data_read))
  
}
names(data)<-positions$positions
```

## collect data from all Scans

```{r}
# rename data according to ScanID

# add attributes to 

```


## list all 



## check data import

```{r}
#library(tidyverse)
#library(xml2)
#library(rvest)


# input: scan_IDs, df containing a column with the ScanID of the data which have to be found

# internal functions
####################

find_server_path<-function(server_path, file_path){
  
  positions<-vector()
  i=1
  
  while ((purrr::is_empty(positions)) & (i <= length(server_path))){
    
    position_path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\',server_path[i],"\\",file_path)
    
    if(file.exists(position_path)==T){
      positions=paste0('\\\\ZKWSCANSRV2\\imagedata\\',server_path[i])%>%file.path()
    }
    
    i=i+1
  }
  
  if((purrr::is_empty(positions)) & (i <= length(server_path))){
    positions = NA
  }
  
  print(positions)
  return(positions)
  
}

get_blob_name<-function(image_path, position){
  
  path<-paste0(image_path,'\\',position,'\\hdr')%>%
    file.path()
  
  files<-list.files(path)
  file<-files[str_detect(files,".blob32$")]
  file<-file%>%str_remove(".blob32$")
  
  return (file)
}

find_picture_informations<- function(image_path, blob_file_name, positions) {
  
  #  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',positions[1,"positions"],'\\hdr\\',positions[1,"blob_file_name"],".blob32.xml")%>%
  path<-paste0(position_path,'\\',positions,'\\hdr\\',blob_file_name,".blob32.xml")%>%
    file.path()
  
  file<-read_xml(path)
  
  size<-file%>%xml_child("size")%>%xml_attrs("size")
  structure<-file%>%xml_child("data-structure")%>%xml_attrs("data-structure")
  statistics<-file%>%xml_child("metadata")%>%xml_child("statistics")%>%xml_attrs("statistics")  
  picture_size<-file%>%xml_child("metadata")%>%xml_child("extent")%>%xml_attrs("extent")
  
  parameter<-c(size,structure,statistics,picture_size)
  
  return(parameter)
}

read_image_bin <- function(image_path, position, blob_file_name, parameter) {
  
  #parameter<-pos['parameter']%>%flatten()
  parameter<-parameter%>%flatten()
  encoding<-parameter[["parameter"]][["encoding"]]
  
  bin_size<-case_when(encoding == "32bit-little-endian" ~ 4,
                      encoding == "16bit-little-endian" ~ 2)
  
  width<-parameter[["parameter"]][["width"]]%>%as.numeric()
  height<-parameter[["parameter"]][["height"]]%>%as.numeric()
  n_pixels<-width * height
  
  #path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',pos$positions,'\\hdr\\',pos$blob_file_name,".blob32")%>%
  path<-paste0(image_path,'\\',position,'\\hdr\\',blob_file_name,".blob32")%>%
    file.path()
  
  data<-readBin(path,
                integer(),
                n=n_pixels,
                size=bin_size)
  
  return (data)
}


find_hdr_data<-function(scan_IDs){
  
  
  # find all local server_path (where data could be)
  ##################################################
  
  server_path<-query_mongoDB(search_value="ImageServerPath",
                             mongo_collection = "limslager",
                             search_object = "EDLType",
                             return_columns = c("FlagEmpty","EDLName"))%>% #,"Do_Not_Check" gibts gar nicht
    filter(FlagEmpty == 0)
  
  # find basePath to the image folder
  ###################################
  
  file_path<-scan_IDs%>%
    mutate(file_path=map(ScanID,
                         ~ query_mongoDB(search_value=.x,
                                         mongo_collection = "scans",
                                         search_object = "UID",
                                         return_columns = "basePath")))%>%
    unnest(file_path)%>%
    select(basePath,everything())
  
  # find for ech ScanID the server_path, where the data could be found and add a new column server_path
  #####################################################################################################
  
  file_path$server_path<-NA
  file_path<-file_path%>%
    select(server_path,everything())
  
  for (k in 1:dim(file_path)[1]){
    
    file_path[k,'server_path']<-find_server_path(server_path = server_path$EDLName,
                                                 file_path = file_path[k,'basePath'])
    
  }
  
  
  # loop through all ScanID
  #########################
  
  data_collection<-list()
  
  for (j in 1:dim(file_path)[1]){
    
    
    # find all positions of a scan
    ###############################
    
    #image_path<-"M619946\\scanjobs\\EZKL150741"  #basePath
    
    position_path<-paste0(file_path[j,"server_path"],'\\',file_path[j,"basePath"])
    
    positions<-list.files(path=position_path)
    
    positions<-tibble(positions=positions[str_detect(positions,"pos")],)
    
    
    # finde für jede Position den Namen der binären hdr und der XML Datei
    #####################################################################
      
    positions<-positions%>%
      mutate(blob_file_name=map2_chr(position_path,positions,~get_blob_name(.x,.y)))
    
    
    # add picture characteristics of each hdr picture to positions df
    #################################################################
    
    positions<-positions%>%
      mutate(parameter = map2(blob_file_name,
                              positions,
                              ~ find_picture_informations(position_path, .x ,.y)))
    
    
    # read in the binary hdr image data and add column to positions
    ###############################################################
    
    data<-list()
    for(i in 1: dim(positions)[1]){
      
      data_read<-read_image_bin(position_path,positions[i,'positions'],positions[i,'blob_file_name'],positions[i,'parameter'])
      data_read<-list(meta_data=positions[i,],data=data_read)
      data<-c(data,list(data_read))
    }
    
    names(data)<-positions$positions
    data_collection<-c(data_collection,list(data))
    #rm(positions,position_path)
  }
  
  
  names(data_collection)<-scan_IDs$ScanID
  return(data_collection)
}


```

```{r}
test<-find_hdr_data(scan_IDs[1,])
```

# package zellkraftwerkr

```{r}
rm(list=ls())
```

```{r}
library(zellkraftwerkr)
```

```{r}
# target antibody
AkID="MZKL211631"
```

```{r}
# find all scans performed with target antibody
scan_IDs<-find_scanID(AkID)
```

```{r}
# find hdr data of all scans and positions
hdr_data<-map(.x=scan_IDs$ScanID,
              ~import_hdr_data(.x))
#scanID<-scan_IDs[1,'ScanID']
#hdr_data<-import_hdr_data(scanID$ScanID)
```

```{r}
# names of hdr_data list
names(hdr_data)<-map(hdr_data,~attributes(.x)$name)%>%unlist()
```

## check data import

1) calculate pixel statistics: mean, median, min, max, n_distinct values
2) compare with metadata

```{r}
check_hdr_import<-function(hdr_data){
  
  # extract statistic metadata from blob file
  data<-hdr_data$metadata
  
  statistics_metadata<-tibble::tibble(positions = hdr_data$positions)%>%
    mutate(mean_pixel=purrr::map_dbl(.x=data,~ .x["mean"]%>%as.numeric),
           median_pixel=purrr::map_dbl(.x=data,~ .x["median"]%>%as.numeric),
           min_pixel=purrr::map_dbl(.x=data,~ .x["min"]%>%as.numeric),
           max_pixel=purrr::map_dbl(.x=data,~ .x["max"]%>%as.numeric),
           n_distinct_pixel=purrr::map_dbl(.x=data,~ .x['distinct-values']%>%as.numeric))%>%
    tidyr::gather("parameter","value",-positions)%>%
    dplyr::mutate(origin ="metadata")

  # map through all positions and calculate statistics for imported hdr_data
  data<-hdr_data$data
  
  statistics_calculated<-tibble::tibble(positions = hdr_data$positions)%>%
    mutate(mean_pixel=purrr::map_dbl(.x=data,~ mean(.x)))%>%
    mutate(median_pixel=purrr::map_dbl(.x=data,~ median(.x)))%>%
    mutate(min_pixel=purrr::map_dbl(.x=data,~ min(.x)))%>%
    mutate(max_pixel=purrr::map_dbl(.x=data,~ max(.x)))%>%
    mutate(n_distinct_pixel=purrr::map_dbl(.x=data,~ length(unique(.x))))%>%
    tidyr::gather("parameter","value",-positions)%>%
    dplyr::mutate(origin ="calculated")%>%
    dplyr::mutate(value=round(value,digits=0))
  
  # join both statistic dataframes and compare values
  
  statistics <- rbind(statistics_calculated,statistics_metadata)%>%
    tidyr::spread(origin,value)
  
  quality <- dplyr::case_when(any(statistics$calculated != statistics$metadata) == FALSE ~ "OK",
                              # at least one parameter value differs (metadata compared to calculation)
                              any(statistics$calculated != statistics$metadata) == TRUE ~ "not OK", 
                              # if there where NA's
                              TRUE ~ "functional error") 
  return(quality)
}

```

```{r}
sapply(hdr_data,check_hdr_import)
```

