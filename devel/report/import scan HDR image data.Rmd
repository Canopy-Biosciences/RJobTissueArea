---
title: " documentation - import scan HDR data"
subtitle: "reportings on functional development"
author: "Julia Ortmann"
output: 
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: '3'
    theme:
      bg: "#202123"
      fg: "#B8BCC2"
      primary: "#EA80FC"
      secondary: "#00DAC6"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
abstract: The aim of this build functions for import of scan HDR images, defined by scan_ID
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = "inst/report/dev report - import scan HDR image data.html",
      envir = globalenv()
    )
  })
---

```{r setup, include=FALSE}
if (requireNamespace("thematic")) 
  thematic::thematic_rmd(font = "auto")
```

# summary

... 

# introduction 

- map over chip_IDs
- find scan_IDs 
- find positions measured and subselected (TO DISCUSS)
- select approbriate scan images
- import blob files
- set grey value threshold
- sum tissue-pixels and position-pixel
- calculate tissue AREA and POSITION AREA
- count cells
- export chipID cell_count tissue and position area 

## import scan HDR image {.tabset .tabset-pills}

### helpers finding paths

#### create_Position_posRefimage_filepath()

```{r}
create_Position_posRefimage_filepath <- function(ScanBasePath,
                                              PositionFolder){
  posRefimage_filepath <- file.path(ScanBasePath,
                                 PositionFolder,
                                 "posref") 
  return(posRefimage_filepath)
  
}
```

#### create_Position_FLimage_filepath()

```{r}
create_Position_FLimage_filepath <- function(ScanBasePath,
                                              PositionFolder){
  FLimage_filepath <- file.path(ScanBasePath,
                                 PositionFolder,
                                 "flimages") 
  return(FLimage_filepath)
  
}
```

#### create_Position_deltaTL_filepath()

```{r}
create_Position_deltaTLimage_filepath <- function(ScanBasePath,
                                              PositionFolder){
  deltaTLimage_filepath <- file.path(ScanBasePath,
                                 PositionFolder,
                                 "deltaTL") 
  return(deltaTLimage_filepath)
  
}
```

#### create_Position__deltaTL_focus_filepath()

```{r}
create_Position_focusimage_filepath <- function(ScanBasePath,
                                              PositionFolder){
  focusimage_filepath <- file.path(ScanBasePath,
                                 PositionFolder,
                                 "focus") 
  return(focusimage_filepath)
  
}
```

#### create_Position_HDRimage_filepath()

```{r}
create_Position_HDRimage_filepath <- function(ScanBasePath,
                                              PositionFolder){
  HDRimage_filepath <- file.path(ScanBasePath,
                                 PositionFolder,
                                 "hdr") 
  return(HDRimage_filepath)
  
}
```

#### list_HDR_BlobFileName_in_filepath()

```{r}
list_BlobFileName_in_filepath <- function(HDRimage_filepath){
  HDRFiles<-list.files(HDRimage_filepath)
  BlobFiles<-HDRFiles[stringr::str_detect(HDRFiles,".blob32$")]
  BlobFileName<-BlobFiles%>%stringr::str_remove(".blob32$")
  if(length(BlobFileName)==0){
    return(NA)
    }else{return(BlobFileName)}
}
```

#### find_scan_basepath()

##### query_UID_scans()

```{r}
# find basePath to the image folder
scan_IDs <- IDs$scan_ID[1:50]

query_UID_scans<- function(scan_IDs){
  result <- query_mongoDB("scans",
                          "UID",
                          scan_IDs)
  
  return(result)
}

query_result <- query_UID_scans(scan_IDs)
```

##### get_df_from_query_result()

```{r}
get_df_from_query_result<- function(query_result){
  
  result <- purrr::map_df(query_result$result, ~.x)
  
  return(result)
  
}

df <- get_df_from_query_result(query_result)

df%>%head()
```

##### find_scan_basepath()

```{r}
find_scan_basepath <- function(scan_IDs){
  query_result <- query_UID_scans(scan_IDs)
  df <- get_df_from_query_result(query_result)
  return(df$basePath)
  
}

IDs <- IDs%>%
  dplyr::mutate(ScanBasePath = find_scan_basepath(scan_ID))

```

### find_all_BlobImageFiles 

- define group_ID
- find all valid chip_IDs in group
- create MethodHistory for each valid chip in group
- extract ScanHistories from MethodHistories
- wrangle to IDs and remove Excluded Scans
- add chip_path
- add ScanHistory
- filter excluded scans
- add ScanBasePath, PositionFolders
- add HDRimage_filepath, FLimage_filepath, posRefimage_filepath
- add BlobFileName
- declare imageType (by available filepath of the available BlobFile of a given scanID)
- wrangle to df containing IDs and corresponding BlobFileNames of each scan
- check for missing  scans

#### worklfow

```{r}
# load library
library(RJobTissueArea)

# define group ID
group_ID <- "P1761451"

# find valid group chip_IDs
chip_IDs <- find_valid_group_chip_IDs(group_ID)

# create chip's MethodHistory
MethodHistory <- create_MethodHistory_of_chipIDs(chip_IDs)

# extract ScanHistory
ScanHistory <- create_ScanHistory_of_chipIDs(MethodHistory)

# df of chip_IDsand all scan_IDs
IDs <- dplyr::tibble(
  chip_ID = chip_IDs)

# add chip_path
IDs <- IDs%>%
  dplyr::mutate(chip_path = purrr::map_chr(chip_ID,
                                    ~find_chip_path(.x)))
# add ScanHistory
IDs <- IDs%>%
  dplyr::mutate(ScanHistory = purrr::map(ScanHistory,~.x))

# unnest IDs
IDs <- IDs%>%
  tidyr::unnest(cols="ScanHistory")

# remove excluded scans
IDs <- IDs%>%
  dplyr::filter(Excluded %in% c(NA, "FALSE"))%>%
  dplyr::filter(Status == "Finished")

# add ScanBasePath
IDs <- IDs%>%
  dplyr::mutate(ScanBasePath = file.path(chip_path,"scanjobs",scan_ID))

# add all PositionFolders found in ScanPath
IDs <- IDs%>%
  dplyr::mutate(
    AllPositionFolders = purrr::map(ScanBasePath,
                                    ~list_posFolders_in_ScanBasePath(.x)))

# unnest AllPositionsFolders
IDs <- IDs%>%
  tidyr::unnest(cols="AllPositionFolders")%>%
  dplyr::rename("PositionFolder" = "AllPositionFolders")

# add HDRimage_filepath
IDs <- IDs%>%
  dplyr::mutate(
    HDRimage_filepath = create_Position_HDRimage_filepath(ScanBasePath,
                                                         PositionFolder))
# add FLimage_filepath
IDs <- IDs%>%
  dplyr::mutate(
    FLimage_filepath = create_Position_FLimage_filepath(ScanBasePath,
                                                        PositionFolder))
# add posRefimage_filepath
IDs <- IDs%>%
  dplyr::mutate(
    posRefimage_filepath = create_Position_posRefimage_filepath(ScanBasePath,
                                                        PositionFolder))

# add deltaTL_filepath
IDs <- IDs%>%
  dplyr::mutate(
    deltaTL_image_filepath = create_Position_deltaTLimage_filepath(ScanBasePath,
                                                        PositionFolder))

# add focus_filepath
IDs <- IDs%>%
  dplyr::mutate(
    focus_image_filepath = create_Position_focusimage_filepath(ScanBasePath,
                                                        PositionFolder))

# add BlobFileName of HDR, FL and posRef images
IDs <- IDs%>%
  dplyr::mutate(
    HDR_BlobFileName = purrr::map_chr(HDRimage_filepath,
                                      ~ list_BlobFileName_in_filepath(.x)),
    FL_BlobFileName = purrr::map_chr(FLimage_filepath,
                                     ~ list_BlobFileName_in_filepath(.x)),
    posRef_BlobFileName = purrr::map_chr(posRefimage_filepath,
                                         ~ list_BlobFileName_in_filepath(.x)),
    deltaTL_BlobFileName = purrr::map_chr(deltaTLimage_filepath,
                                         ~ list_BlobFileName_in_filepath(.x)),
    focus_BlobFileName = purrr::map_chr(focusimage_filepath,
                                         ~ list_BlobFileName_in_filepath(.x)))

# create df of all scans and corresponding blob filenames
BlobPaths_chip_group <- IDs%>%
  dplyr::select(chip_ID,
                scan_ID,
                cycle_ID,
                Status,
                Excluded,
                HDR_BlobFileName,
                FL_BlobFileName,
                posRef_BlobFileName,
                deltaTL_BlobFileName,
                focus_BlobFileName
                )

# reduce BlobFileNames to ImageType of a certain scanID
BlobPaths_chip_group <- BlobPaths_chip_group%>%
  tidyr::pivot_longer(cols=c("HDR_BlobFileName",
                             "FL_BlobFileName",
                             "posRef_BlobFileName",
                             "deltaTL_BlobFileName",
                             "focus_BlobFileName"),
                      names_to = "ImageType",
                      values_to = "BlobFileName")%>%
  dplyr::mutate(ImageType = stringr::str_split(ImageType,"_",simplify = TRUE)[,1])%>%
  dplyr::filter(!is.na(BlobFileName))
```

#### check scanIDs for missinng image data

```{r}
# check missing scanIDs
missing_scans <- which(! result$UID %in% BlobPaths_chip_group$scan_ID)

missing_scan_IDs <-unique(result$UID[missing_scans])


MH <- MethodHistory%>%data.table::rbindlist(,fill=TRUE)

MH%>%dplyr::filter(UID %in% missing_scan_IDs)
result%>%dplyr::filter(UID%in% missing_scan_IDs)
```

# supplement

## add picture characteristics to positions df

```{r,eval=FALSE}
#for testing
image_path<-"M619946\\scanjobs\\EZKL150741"

# suche für jede Position aus der XML die notwendigen Infos heraus, damit die HDR Blob eingelesen werden kann
#width=1392
#height=1040
#encoding="32bit-little-endian"

# statistic parameter um den Einlesevorgang zu überprüfen
# min
# max
# distinct
# median

find_picture_informations<- function(image_path, blob_file_name, positions) {
  
#  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',positions[1,"positions"],'\\hdr\\',positions[1,"blob_file_name"],".blob32.xml")%>%
    path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',positions,'\\hdr\\',blob_file_name,".blob32.xml")%>%
      file.path()
  
  file<-read_xml(path)
  
  size<-file%>%xml_child("size")%>%xml_attrs("size")
  structure<-file%>%xml_child("data-structure")%>%xml_attrs("data-structure")
  statistics<-file%>%xml_child("metadata")%>%xml_child("statistics")%>%xml_attrs("statistics")
  picture_size<-file%>%xml_child("metadata")%>%xml_child("extent")%>%xml_attrs("extent") 
  
  #parameter<-tibble(value=c(size,structure,statistics),
  #                  name=c(names(size),names(structure),names(statistics)))
  #names(parameter) <- c(names(size),names(structure),names(statistics))
  
  parameter<-c(size,structure,statistics,picture_size)
  
  return(parameter)
}

```

## add list column to positions df, containing intensitys per pixel

```{r,eval=FALSE}
read_image_bin <- function(image_path, position, blob_file_name, parameter) {
  
  #parameter<-pos['parameter']%>%flatten()
  parameter<-parameter%>%flatten()
  encoding<-parameter[["parameter"]][["encoding"]]
  
  bin_size<-case_when(encoding == "32bit-little-endian" ~ 4,
                      encoding == "16bit-little-endian" ~ 2)
  
  width<-parameter[["parameter"]][["width"]]%>%as.numeric()
  height<-parameter[["parameter"]][["height"]]%>%as.numeric()
  n_pixels<-width * height
  
  #path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',pos$positions,'\\hdr\\',pos$blob_file_name,".blob32")%>%
  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',position,'\\hdr\\',blob_file_name,".blob32")%>%
    file.path()
  
  data<-readBin(path,
                integer(),
                n=n_pixels,
                size=bin_size)
  
  return (data)
} 

```

## collect data from all Scans

```{r}
# rename data according to ScanID

# add attributes to 

```

## list all 

## check data import

```{r,eval=FALSE}

find_picture_informations<- function(image_path, blob_file_name, positions) {
  
  #  path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',positions[1,"positions"],'\\hdr\\',positions[1,"blob_file_name"],".blob32.xml")%>%
  path<-paste0(position_path,'\\',positions,'\\hdr\\',blob_file_name,".blob32.xml")%>%
    file.path()
  
  file<-read_xml(path)
  
  size<-file%>%xml_child("size")%>%xml_attrs("size")
  structure<-file%>%xml_child("data-structure")%>%xml_attrs("data-structure")
  statistics<-file%>%xml_child("metadata")%>%xml_child("statistics")%>%xml_attrs("statistics")  
  picture_size<-file%>%xml_child("metadata")%>%xml_child("extent")%>%xml_attrs("extent")
  
  parameter<-c(size,structure,statistics,picture_size)
  
  return(parameter)
}

read_image_bin <- function(image_path, position, blob_file_name, parameter) {
  
  #parameter<-pos['parameter']%>%flatten()
  parameter<-parameter%>%flatten()
  encoding<-parameter[["parameter"]][["encoding"]]
  
  bin_size<-case_when(encoding == "32bit-little-endian" ~ 4,
                      encoding == "16bit-little-endian" ~ 2)
  
  width<-parameter[["parameter"]][["width"]]%>%as.numeric()
  height<-parameter[["parameter"]][["height"]]%>%as.numeric()
  n_pixels<-width * height
  
  #path<-paste0('\\\\ZKWSCANSRV2\\imagedata\\leipzig_volume0\\',image_path,'\\',pos$positions,'\\hdr\\',pos$blob_file_name,".blob32")%>%
  path<-paste0(image_path,'\\',position,'\\hdr\\',blob_file_name,".blob32")%>%
    file.path()
  
  data<-readBin(path,
                integer(),
                n=n_pixels,
                size=bin_size)
  
  return (data)
}


find_hdr_data<-function(scan_IDs){
  
  
  # find all local server_path (where data could be)
  ##################################################
  
  server_path<-query_mongoDB(search_value="ImageServerPath",
                             mongo_collection = "limslager",
                             search_object = "EDLType",
                             return_columns = c("FlagEmpty","EDLName"))%>% #,"Do_Not_Check" gibts gar nicht
    filter(FlagEmpty == 0)
  
  # find basePath to the image folder
  ###################################
  
  file_path<-scan_IDs%>%
    mutate(file_path=map(ScanID,
                         ~ query_mongoDB(search_value=.x,
                                         mongo_collection = "scans",
                                         search_object = "UID",
                                         return_columns = "basePath")))%>%
    unnest(file_path)%>%
    select(basePath,everything())
  
  # find for ech ScanID the server_path, where the data could be found and add a new column server_path
  #####################################################################################################
  
  file_path$server_path<-NA
  file_path<-file_path%>%
    select(server_path,everything())
  
  for (k in 1:dim(file_path)[1]){
    
    file_path[k,'server_path']<-find_server_path(server_path = server_path$EDLName,
                                                 file_path = file_path[k,'basePath'])
    
  }
  
  
  # loop through all ScanID
  #########################
  
  data_collection<-list()
  
  for (j in 1:dim(file_path)[1]){
    
    
    # find all positions of a scan
    ###############################
    
    #image_path<-"M619946\\scanjobs\\EZKL150741"  #basePath
    
    position_path<-paste0(file_path[j,"server_path"],'\\',file_path[j,"basePath"])
    
    positions<-list.files(path=position_path)
    
    positions<-tibble(positions=positions[str_detect(positions,"pos")],)
    
    
    # finde für jede Position den Namen der binären hdr und der XML Datei
    #####################################################################
      
    positions<-positions%>%
      mutate(blob_file_name=map2_chr(position_path,positions,~get_blob_name(.x,.y)))
    
    
    # add picture characteristics of each hdr picture to positions df
    #################################################################
    
    positions<-positions%>%
      mutate(parameter = map2(blob_file_name,
                              positions,
                              ~ find_picture_informations(position_path, .x ,.y)))
    
    
    # read in the binary hdr image data and add column to positions
    ###############################################################
    
    data<-list()
    for(i in 1: dim(positions)[1]){
      
      data_read<-read_image_bin(position_path,positions[i,'positions'],positions[i,'blob_file_name'],positions[i,'parameter'])
      data_read<-list(meta_data=positions[i,],data=data_read)
      data<-c(data,list(data_read))
    }
    
    names(data)<-positions$positions
    data_collection<-c(data_collection,list(data))
    #rm(positions,position_path)
  }
  
  
  names(data_collection)<-scan_IDs$ScanID
  return(data_collection)
}


```


## check data import

1) calculate pixel statistics: mean, median, min, max, n_distinct values
2) compare with metadata

```{r,eval=FALSE}
check_hdr_import<-function(hdr_data){
  
  # extract statistic metadata from blob file
  data<-hdr_data$metadata
  
  statistics_metadata<-tibble::tibble(positions = hdr_data$positions)%>%
    mutate(mean_pixel=purrr::map_dbl(.x=data,~ .x["mean"]%>%as.numeric),
           median_pixel=purrr::map_dbl(.x=data,~ .x["median"]%>%as.numeric),
           min_pixel=purrr::map_dbl(.x=data,~ .x["min"]%>%as.numeric),
           max_pixel=purrr::map_dbl(.x=data,~ .x["max"]%>%as.numeric),
           n_distinct_pixel=purrr::map_dbl(.x=data,~ .x['distinct-values']%>%as.numeric))%>%
    tidyr::gather("parameter","value",-positions)%>%
    dplyr::mutate(origin ="metadata")

  # map through all positions and calculate statistics for imported hdr_data
  data<-hdr_data$data
  
  statistics_calculated<-tibble::tibble(positions = hdr_data$positions)%>%
    mutate(mean_pixel=purrr::map_dbl(.x=data,~ mean(.x)))%>%
    mutate(median_pixel=purrr::map_dbl(.x=data,~ median(.x)))%>%
    mutate(min_pixel=purrr::map_dbl(.x=data,~ min(.x)))%>%
    mutate(max_pixel=purrr::map_dbl(.x=data,~ max(.x)))%>%
    mutate(n_distinct_pixel=purrr::map_dbl(.x=data,~ length(unique(.x))))%>%
    tidyr::gather("parameter","value",-positions)%>%
    dplyr::mutate(origin ="calculated")%>%
    dplyr::mutate(value=round(value,digits=0))
  
  # join both statistic dataframes and compare values
  
  statistics <- rbind(statistics_calculated,statistics_metadata)%>%
    tidyr::spread(origin,value)
  
  quality <- dplyr::case_when(any(statistics$calculated != statistics$metadata) == FALSE ~ "OK",
                              # at least one parameter value differs (metadata compared to calculation)
                              any(statistics$calculated != statistics$metadata) == TRUE ~ "not OK", 
                              # if there where NA's
                              TRUE ~ "functional error") 
  return(quality)
}

```

```{r,eval=FALSE}
sapply(hdr_data,check_hdr_import)
```

