

$\sum{(Px(value==1)*px\_resolution ^2 )}$

```{r}
library(pixmap)
library(magrittr)
library(EBImage)
library(image.LineSegmentDetector)
library(image.ContourDetector)
library(image.CannyEdges)

setwd("~/Zellkraftwerk/packages/RJobTissueArea")

file <- file.path("inst/data","data_sum_M1730408_pos11.csv")

data.sum <- file%>%
  data.table::fread()

m.data_sum <- data.sum%>%
  as.matrix()

#cellres: pixel resolution in horizontal and vertical direction

image <-pixmapGrey(m.data_sum,cellres=c(1,1))

plot(image)
```

# EBImage

## constant threshold

```{r}
grid <- expand.grid(
  sigma = seq(0.5,3,0.4),
  threshold = seq(2,4,0.25)
)
grid$min <- NA
grid$max <- NA

img2 <- image@grey * 255
# Set up plots for 96 dpi images
  #library(EBImage)
  #dm <- dim(img2)/96
  #dev.new(width = dm[1], height = dm[2])
# Low pass filter with gblur and make binary

  par(mfrow=c(1,2))
  
for(i in 1:dim(grid)[1]){

    writeLines(c(
    paste0("- sigma: ",grid$sigma[i]),
    paste0("- threshold: ", grid$threshold[i])
  ))

  #Low-pass Gaussian filter
  xb <- EBImage::gblur(img2, grid$sigma[i])
  xb <- round(xb,digits = 0)
  #plot(xb)

  image2 <- pixmapGrey(xb,cellres=c(1,1)) #(xb-min(xb))/(max(xb)-min(xb))

  plot(image2)

  grid$min[i] <- min(xb)
  grid$max[i] <- max(xb)
  
  #threshold filtering
  pos <- which(xb > grid$threshold[i])
  xt <- xb
  xt[which(xb > grid$threshold[i])] <- 1
  xt[which(xb <= grid$threshold[i])] <- 0
  
 #xt <- EBImage::thresh(xb, w=grid$w[i],
 #                      h=grid$w[i],
 #                      offset = grid$offset[i])
 #plot(xt)

 image3 <- image
 image3@grey <- xt

 plot(image3)
}

grid
write.csv(grid,"grid_resulttable.csv")
```

# supplement

## adapting threshold

```{r,eval=FALSE}

grid <- expand.grid(sigma = c(1,2,3,4,5,10,100),
             offset = c(100,10,1,0,0.01,0.001,0.0001,0.00001,0.000001,0.0000001),
             w=c(1,5,10,50))

img2 <- image@grey * 255
# Set up plots for 96 dpi images
  #library(EBImage)
  #dm <- dim(img2)/96
  #dev.new(width = dm[1], height = dm[2])
# Low pass filter with gblur and make binary

for(i in 1:dim(grid)[1]){

    writeLines(c(
    paste0("- sigma: ",grid$sigma[i]),
    paste0("- offset: ", grid$offset[i]),
    paste0(" - w and h: ",grid$w[i])
  ))

  #Low-pass Gaussian filter
  xb <- EBImage::gblur(img2, grid$sigma[i])
  plot(xb)

  image2 <- pixmapGrey(xb,cellres=c(1,1)) #(xb-min(xb))/(max(xb)-min(xb))

  plot(image2)


  xt <- EBImage::thresh(xb, w=grid$w[i],
                        h=grid$w[i],
                        offset = grid$offset[i])
  plot(xt)

  image3 <- image
  image3@grey <- xt

  plot(image3)
}

```

## image_line_segment_detector

```{r,eval=FALSE}
x <- image@grey * 255

linesegments <- image_line_segment_detector(x,
                                            scale = 0.8,
                                            sigma_scale = 0.6,
                                            quant = 2,
                                            ang_th = 22.5,
                                            log_eps = 0,
                                            density_th = 0.7,
                                            n_bins = 1024,
                                            union = FALSE,
                                            union_min_length = 5,
                                            union_max_distance = 5,
                                            union_ang_th = 7,
                                            union_use_NFA = FALSE,
                                            union_log_eps = 0)

linesegments
plot(image)
plot(linesegments, add = TRUE, col = "red")
```

## image_contour_detector

```{r,eval=FALSE}
contourlines  <- image_contour_detector(x, Q = 2)
contourlines
plot(image)
plot(contourlines, add = TRUE, col = "red")
```

## image_canny_edge_detector

```{r,eval=FALSE}
edges <- image_canny_edge_detector(x)
edges
plot(edges)
```
